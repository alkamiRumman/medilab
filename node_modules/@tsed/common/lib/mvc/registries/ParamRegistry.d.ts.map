{"version":3,"sources":["mvc/registries/ParamRegistry.ts"],"names":[],"mappings":"AAAA,OAAO,EAAuB,IAAI,EAAC,MAAM,YAAY,CAAC;AAEtD,OAAO,EAAC,wBAAwB,EAAE,aAAa,EAAC,MAAM,yBAAyB,CAAC;AAChF,OAAO,EAAC,UAAU,EAAC,MAAM,sBAAsB,CAAC;AAEhD,qBAAa,aAAa;IACxB,MAAM,CAAC,GAAG,CAAC,MAAM,EAAE,IAAI,CAAC,GAAG,CAAC,EAAE,WAAW,EAAE,MAAM,GAAG,MAAM,EAAE,KAAK,EAAE,MAAM,GAAG,aAAa;IAWzF,MAAM,CAAC,GAAG,CAAC,MAAM,EAAE,IAAI,CAAC,GAAG,CAAC,EAAE,WAAW,EAAE,MAAM,GAAG,MAAM,EAAE,KAAK,EAAE,MAAM;IAIzE,MAAM,CAAC,GAAG,CAAC,MAAM,EAAE,IAAI,CAAC,GAAG,CAAC,EAAE,WAAW,EAAE,MAAM,GAAG,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,aAAa,EAAE,aAAa,GAAG,IAAI;IAQ9G,MAAM,CAAC,SAAS,CAAC,MAAM,EAAE,IAAI,CAAC,GAAG,CAAC,EAAE,WAAW,EAAE,MAAM,GAAG,MAAM,GAAG,aAAa,EAAE;IAIlF;;;;;;;OAOG;IAGH,MAAM,CAAC,QAAQ,CAAC,MAAM,EAAE,IAAI,CAAC,GAAG,CAAC,EAAE,WAAW,EAAE,MAAM,GAAG,MAAM,EAAE,cAAc,EAAE,MAAM,EAAE,qBAAqB,GAAE,GAAG,EAAO;IAe1H;;;;;;OAMG;IAGH,MAAM,CAAC,QAAQ,CAAC,KAAK,EAAE,MAAM,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,UAAU,EAAE,OAAO,GAAE,OAAO,CAAC,wBAAwB,CAAM,GAAG,kBAAkB;IAiB5H,MAAM,CAAC,SAAS,CAAC,MAAM,EAAE,MAAM,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,UAAU,EAAE,OAAO,EAAE,wBAAwB,GAAG,aAAa;CA4B5G","file":"ParamRegistry.d.ts","sourcesContent":["import {Deprecated, Metadata, Type} from \"@tsed/core\";\nimport {PARAM_METADATA} from \"../constants\";\nimport {IParamConstructorOptions, ParamMetadata} from \"../models/ParamMetadata\";\nimport {ParamTypes} from \"../models/ParamTypes\";\n\nexport class ParamRegistry {\n  static get(target: Type<any>, propertyKey: string | symbol, index: number): ParamMetadata {\n    const params = this.getParams(target, propertyKey);\n\n    if (!this.has(target, propertyKey, index)) {\n      params[index] = new ParamMetadata({target, propertyKey, index});\n      this.set(target, propertyKey, index, params[index]);\n    }\n\n    return params[index];\n  }\n\n  static has(target: Type<any>, propertyKey: string | symbol, index: number) {\n    return !!this.getParams(target, propertyKey)[index];\n  }\n\n  static set(target: Type<any>, propertyKey: string | symbol, index: number, paramMetadata: ParamMetadata): void {\n    const params = this.getParams(target, propertyKey);\n\n    params[index] = paramMetadata;\n\n    Metadata.set(PARAM_METADATA, params, target, propertyKey);\n  }\n\n  static getParams(target: Type<any>, propertyKey: string | symbol): ParamMetadata[] {\n    return Metadata.has(PARAM_METADATA, target, propertyKey) ? Metadata.get(PARAM_METADATA, target, propertyKey) : [];\n  }\n\n  /**\n   *\n   * @param target\n   * @param propertyKey\n   * @param parameterIndex\n   * @param allowedRequiredValues\n   * @deprecated\n   */\n  // istanbul ignore next\n  @Deprecated(\"ParamRegistry.decorate are deprecated.\")\n  static required(target: Type<any>, propertyKey: string | symbol, parameterIndex: number, allowedRequiredValues: any[] = []) {\n    const param = ParamRegistry.get(target, propertyKey, parameterIndex);\n\n    param.required = true;\n    param.allowedRequiredValues = allowedRequiredValues;\n\n    param.store.merge(\"responses\", {\n      \"400\": {\n        description: \"BadRequest\"\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Create a parameters decorators\n   * @param token\n   * @param {Partial<IParamConstructorOptions<any>>} options\n   * @returns {Function}\n   * @deprecated\n   */\n  // istanbul ignore next\n  @Deprecated(\"ParamRegistry.decorate are deprecated. Use UseFilter decorator instead\")\n  static decorate(token: string | Type<any> | ParamTypes, options: Partial<IParamConstructorOptions> = {}): ParameterDecorator {\n    return (target: Type<any>, propertyKey: string | symbol, index: number): any => {\n      if (typeof index === \"number\") {\n        const settings = Object.assign(\n          {\n            target,\n            propertyKey,\n            index\n          },\n          options\n        );\n\n        ParamRegistry.useFilter(token, settings);\n      }\n    };\n  }\n\n  static useFilter(filter: string | Type<any> | ParamTypes, options: IParamConstructorOptions): ParamMetadata {\n    const {expression, useType, propertyKey, index, target, useConverter, useValidation} = options;\n    let {paramType} = options;\n\n    const param = ParamRegistry.get(target, propertyKey, index);\n\n    if (typeof filter === \"string\") {\n      paramType = filter as ParamTypes;\n    }\n\n    param.service = filter;\n    param.useValidation = !!useValidation;\n    param.expression = expression!;\n\n    if (paramType) {\n      param.paramType = paramType!;\n    }\n\n    if (useType) {\n      param.type = useType;\n    }\n\n    if (useConverter !== undefined) {\n      param.useConverter = useConverter;\n    }\n\n    return param;\n  }\n}\n"],"sourceRoot":"../../../src"}