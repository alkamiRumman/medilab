{"version":3,"sources":["mvc/decorators/allow.ts"],"names":[],"mappings":"AAKA;;;;;;;;;;;;;;;;;;;;;;;;GAwBG;AACH,wBAAgB,KAAK,CAAC,GAAG,qBAAqB,EAAE,GAAG,EAAE,GAAG,GAAG,CAyB1D","file":"allow.d.ts","sourcesContent":["import {DecoratorParameters, getDecoratorType, UnsupportedDecoratorType} from \"@tsed/core\";\nimport {JsonSchema} from \"../../jsonschema/class/JsonSchema\";\nimport {decoratorSchemaFactory} from \"../../jsonschema/utils/decoratorSchemaFactory\";\nimport {getStorableMetadata} from \"./utils/getStorableMetadata\";\n\n/**\n * Add allowed values when the property or parameters is required.\n *\n * #### Example on parameter:\n *\n * ```typescript\n * @Post(\"/\")\n * async method(@Required() @Allow(\"\") @BodyParams(\"field\") field: string) {}\n * ```\n * > Required will throw a BadRequest when the given value is `null` or `undefined` but not for an empty string.\n *\n * #### Example on model:\n *\n * ```typescript\n * class Model {\n *   @Property()\n *   @Required()\n *   @Allow(\"\")\n *   field: string;\n * }\n * ```\n *\n * @returns {Function}\n * @decorator\n */\nexport function Allow(...allowedRequiredValues: any[]): any {\n  const allowNullInSchema = decoratorSchemaFactory((schema: JsonSchema) => {\n    if (schema && schema.mapper) {\n      if (schema.mapper.$ref) {\n        schema.mapper.oneOf = [{type: \"null\"}, {$ref: schema.mapper.$ref}];\n        delete schema.mapper.$ref;\n      } else {\n        schema.mapper.type = [].concat(schema.type, [\"null\"] as any);\n      }\n    }\n  });\n\n  return (...decoratorArgs: DecoratorParameters): void => {\n    const metadata = getStorableMetadata(decoratorArgs);\n\n    if (!metadata) {\n      throw new UnsupportedDecoratorType(Allow, decoratorArgs);\n    }\n\n    metadata.allowedRequiredValues = allowedRequiredValues;\n\n    if (getDecoratorType(decoratorArgs, true) === \"property\" && allowedRequiredValues.some(e => e == null)) {\n      allowNullInSchema(decoratorArgs[0], decoratorArgs[1]);\n    }\n  };\n}\n"],"sourceRoot":"../../../src"}