{"version":3,"sources":["mvc/builders/HandlerBuilder.ts"],"names":[],"mappings":"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","file":"HandlerBuilder.js","sourcesContent":["import {isFunction, isPromise, isStream, nameOf} from \"@tsed/core\";\nimport {InjectorService} from \"@tsed/di\";\nimport {isObservable, Observable, Subject, zip} from \"rxjs\";\nimport {map} from \"rxjs/operators\";\nimport {HandlerType} from \"../interfaces/HandlerType\";\nimport {IHandlerContext} from \"../interfaces/IHandlerContext\";\nimport {EndpointMetadata} from \"../models/EndpointMetadata\";\nimport {HandlerMetadata, IHandlerConstructorOptions} from \"../models/HandlerMetadata\";\nimport {ParamMetadata} from \"../models/ParamMetadata\";\nimport {ParamBuilder} from \"./ParamBuilder\";\n\n/**\n * @stable\n */\nexport class HandlerBuilder {\n  private debug: boolean;\n\n  constructor(private handlerMetadata: HandlerMetadata) {}\n\n  /**\n   *\n   * @param obj\n   * @returns {HandlerBuilder}\n   */\n  static from(obj: any | EndpointMetadata) {\n    return {\n      build(injector: InjectorService) {\n        const handlerMetadata = HandlerBuilder.resolve(obj, injector);\n\n        if (handlerMetadata.type === HandlerType.FUNCTION) {\n          // injector.logger.debug(\"Return handler as function\", handlerMetadata.handler.name);\n          return handlerMetadata.handler;\n        }\n\n        // injector.logger.trace(\"Build handler\", `${nameOf(handlerMetadata.target)}.${handlerMetadata.method}()`);\n        return new HandlerBuilder(handlerMetadata).build(injector);\n      }\n    };\n  }\n\n  static resolve(obj: any | EndpointMetadata, injector: InjectorService) {\n    let options: IHandlerConstructorOptions;\n\n    if (obj instanceof EndpointMetadata) {\n      const provider = injector.getProvider(obj.target)!;\n\n      options = {\n        token: provider.provide,\n        target: provider.useClass,\n        type: HandlerType.CONTROLLER,\n        propertyKey: obj.propertyKey\n      };\n    } else {\n      const provider = injector.getProvider(obj);\n\n      if (provider) {\n        options = {\n          token: provider.provide,\n          target: provider.useClass,\n          type: HandlerType.MIDDLEWARE,\n          propertyKey: \"use\"\n        };\n      } else {\n        options = {\n          target: obj,\n          type: HandlerType.FUNCTION\n        };\n      }\n    }\n\n    return new HandlerMetadata(options);\n  }\n\n  static handle(process: any, context: IHandlerContext) {\n    const {\n      handler: {hasNextFunction},\n      request,\n      response,\n      next\n    } = context;\n\n    const done = (error: any, result?: any) => {\n      if (error) {\n        return next(error);\n      }\n\n      if (!hasNextFunction) {\n        // @ts-ignore\n        if (!next.isCalled && result !== undefined) {\n          request.ctx.data = result;\n        }\n        next();\n      }\n    };\n\n    if (process) {\n      if (process === context.response) {\n        return;\n      }\n\n      if (isObservable(process)) {\n        process = process.toPromise();\n      }\n\n      if (isStream(process)) {\n        return done(null, process);\n      }\n\n      if (isFunction(process)) {\n        // when process return a middleware\n        return process(request, response, next);\n      }\n\n      if (isPromise(process)) {\n        return process.then((result: any) => this.handle(result, context)).catch((error: any) => done(error));\n      }\n    }\n\n    if (!hasNextFunction) {\n      // no next function and empty response\n      done(null, process);\n    }\n  }\n\n  /**\n   *\n   * @returns {any}\n   */\n  public build(injector: InjectorService): any {\n    const {hasErrorParam} = this.handlerMetadata;\n\n    this.debug = injector.settings.debug;\n\n    const dispatch = this.createDispatcher(injector);\n\n    if (hasErrorParam) {\n      return (err: any, request: any, response: any, next: any) =>\n        dispatch({\n          request,\n          response,\n          next,\n          err,\n          handler: this.handlerMetadata,\n          args: []\n        });\n    } else {\n      return (request: any, response: any, next: any) =>\n        dispatch({\n          request,\n          response,\n          next,\n          handler: this.handlerMetadata,\n          args: []\n        });\n    }\n  }\n\n  private createDispatcher(injector: InjectorService) {\n    const {\n      handlerMetadata: {parameters}\n    } = this;\n    const requestSubject = new Subject<IHandlerContext>();\n    const sources: Subject<IHandlerContext>[] = [requestSubject];\n    const observables: Observable<any>[] = [requestSubject];\n\n    // Build parameters\n    parameters.forEach((param: ParamMetadata) => {\n      const {subject, observable} = new ParamBuilder(param).build(injector);\n      sources.push(subject);\n      observables.push(observable);\n    });\n\n    const mapContext = map(([context, ...args]) => {\n      context.args = args;\n      context.next = this.buildNext(context);\n\n      return context;\n    });\n\n    zip(...observables)\n      .pipe(mapContext)\n      .subscribe(context => this.invoke(injector, context));\n\n    // Return dispatcher\n    return (context: IHandlerContext) => {\n      this.log(context, {event: \"invoke.start\"});\n\n      sources.forEach(source => {\n        source.next(context);\n      });\n    };\n  }\n\n  /**\n   *\n   * @returns {Promise<any>}\n   * @param injector\n   * @param context\n   */\n  private invoke(injector: InjectorService, context: IHandlerContext) {\n    try {\n      const {token, method} = this.handlerMetadata;\n\n      this.checkContext(context);\n\n      const instance: any = injector.invoke(token, context.request.ctx.container);\n      const handler = instance[method!].bind(instance);\n      const process = handler(...context.args);\n\n      HandlerBuilder.handle(process, context);\n    } catch (error) {\n      context.next(error);\n    }\n  }\n\n  /**\n   *\n   * @param context\n   * @param o\n   * @returns {string}\n   */\n  private log(context: IHandlerContext, o: any = {}) {\n    const {request} = context;\n\n    if (request.log && this.debug) {\n      const {target, injectable, method} = this.handlerMetadata;\n\n      request.log.debug(\n        {\n          type: this.handlerMetadata.type,\n          target: (target ? nameOf(target) : target.name) || \"anonymous\",\n          methodName: method,\n          injectable,\n          data: request.ctx.data,\n          ...o\n        },\n        false\n      );\n    }\n  }\n\n  private checkContext(context: IHandlerContext) {\n    const error = context.args.find(arg => arg instanceof Error && arg !== context.err);\n\n    if (error) {\n      throw error;\n    }\n  }\n\n  /**\n   *\n   * @returns {any}\n   * @param context\n   */\n  private buildNext(context: IHandlerContext): any {\n    // @ts-ignore\n    const next = context.next as any;\n    const dateTime = Date.now();\n\n    next.isCalled = false;\n\n    return (error?: any) => {\n      next.isCalled = true;\n      if (context.response.headersSent) {\n        return;\n      }\n\n      /* istanbul ignore else */\n      this.log(context, {event: \"invoke.end\", error, execTime: Date.now() - dateTime});\n\n      return next(error);\n    };\n  }\n}\n"],"sourceRoot":"../../../src"}