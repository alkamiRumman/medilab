{"version":3,"sources":["mvc/builders/ParamBuilder.ts"],"names":[],"mappings":"AACA,OAAO,EAAC,eAAe,EAAC,MAAM,UAAU,CAAC;AACzC,OAAO,EAAK,OAAO,EAAC,MAAM,MAAM,CAAC;AAOjC,OAAO,EAAC,eAAe,EAAE,aAAa,EAAC,MAAM,+BAA+B,CAAC;AAC7E,OAAO,EAAC,aAAa,EAAC,MAAM,yBAAyB,CAAC;AAItD,qBAAa,YAAY;IACX,OAAO,CAAC,KAAK;gBAAL,KAAK,EAAE,aAAa;IAExC;;;;;OAKG;IACH,MAAM,CAAC,gBAAgB,CAAC,KAAK,EAAE,aAAa,EAAE,QAAQ,EAAE,eAAe;IAWvE;;;;;OAKG;IACH,MAAM,CAAC,iBAAiB,CAAC,KAAK,EAAE,aAAa,EAAE,QAAQ,EAAE,eAAe;IAqBxE,MAAM,CAAC,sBAAsB,CAAC,KAAK,EAAE,aAAa;IAelD;;;;OAIG;IACH,MAAM,CAAC,eAAe,CAAC,KAAK,EAAE,aAAa;IAc3C,MAAM,CAAC,cAAc,CAAC,KAAK,EAAE,aAAa,EAAE,QAAQ,EAAE,eAAe,GAAG,CAAC,OAAO,EAAE,aAAa,KAAK,GAAG;IAoDvG,MAAM,CAAC,kBAAkB,CAAC,KAAK,EAAE,aAAa,EAAE,QAAQ,EAAE,eAAe,GAAG,GAAG;IAe/E,OAAO,CAAC,MAAM,CAAC,gBAAgB;IAkB/B,OAAO,CAAC,MAAM,CAAC,cAAc;IAQtB,KAAK,CAAC,QAAQ,EAAE,eAAe;;;;CAUvC","file":"ParamBuilder.d.ts","sourcesContent":["import {getValue, nameOf, Type} from \"@tsed/core\";\nimport {InjectorService} from \"@tsed/di\";\nimport {of, Subject} from \"rxjs\";\nimport {catchError, map, switchMap} from \"rxjs/operators\";\nimport {ConverterService} from \"../../converters\";\nimport {ParseExpressionError} from \"../errors/ParseExpressionError\";\nimport {RequiredParamError} from \"../errors/RequiredParamError\";\nimport {UnknowFilterError} from \"../errors/UnknowFilterError\";\nimport {IFilter} from \"../interfaces\";\nimport {IHandlerContext, IParamContext} from \"../interfaces/IHandlerContext\";\nimport {ParamMetadata} from \"../models/ParamMetadata\";\nimport {ParamTypes} from \"../models/ParamTypes\";\nimport {ValidationService} from \"../services/ValidationService\";\n\nexport class ParamBuilder {\n  constructor(private param: ParamMetadata) {}\n\n  /**\n   *\n   * @param param\n   * @param injector\n   * @returns {(value: any) => any}\n   */\n  static getConverterPipe(param: ParamMetadata, injector: InjectorService) {\n    if (!param.useConverter) {\n      return;\n    }\n    const converterService = injector.get<ConverterService>(ConverterService)!;\n\n    return (value: any) => {\n      return converterService.deserialize(value, param.collectionType || param.type, param.type);\n    };\n  }\n\n  /**\n   *\n   * @param param\n   * @param injector\n   * @returns {(value: any) => any}\n   */\n  static getValidationPipe(param: ParamMetadata, injector: InjectorService) {\n    const {collectionType} = param;\n    const type = param.type || param.collectionType;\n\n    if (!param.useValidation || (param.useValidation && !type)) {\n      return;\n    }\n\n    const validationService = injector.get<ValidationService>(ValidationService)!;\n\n    return (value: any) => {\n      try {\n        validationService.validate(value, type, collectionType);\n      } catch (err) {\n        throw new ParseExpressionError(nameOf(param.service), param.expression, err);\n      }\n\n      return value;\n    };\n  }\n\n  static getParseExpressionPipe(param: ParamMetadata) {\n    const {service} = param;\n    let {expression} = param;\n\n    if (typeof service !== \"string\" || !expression) {\n      return;\n    }\n\n    if (service === ParamTypes.HEADER) {\n      expression = (param.expression || \"\").toLowerCase();\n    }\n\n    return (value: any) => getValue(expression, value);\n  }\n\n  /**\n   *\n   * @param {ParamMetadata} param\n   * @returns {(value: any) => any}\n   */\n  static getRequiredPipe(param: ParamMetadata) {\n    if (!param.required) {\n      return;\n    }\n\n    return (value: any) => {\n      if (param.isRequired(value)) {\n        throw new RequiredParamError(nameOf(param.service), param.expression);\n      }\n\n      return value;\n    };\n  }\n\n  static getInitialPipe(param: ParamMetadata, injector: InjectorService): (context: IParamContext) => any {\n    const requestPipe: (context: IParamContext) => any = context => context.request;\n    const contextPipe: (context: IParamContext) => any = context => requestPipe(context).ctx;\n\n    switch (param.service) {\n      case ParamTypes.BODY:\n        return context => requestPipe(context).body;\n\n      case ParamTypes.QUERY:\n        return context => requestPipe(context).query;\n\n      case ParamTypes.PATH:\n        return context => requestPipe(context).params;\n\n      case ParamTypes.HEADER:\n        return context => requestPipe(context).headers;\n\n      case ParamTypes.COOKIES:\n        return context => requestPipe(context).cookies;\n\n      case ParamTypes.SESSION:\n        return context => requestPipe(context).session;\n\n      case ParamTypes.LOCALS:\n        return context => requestPipe(context).locals;\n\n      case ParamTypes.RESPONSE:\n        return context => context.response;\n\n      case ParamTypes.REQUEST:\n        return requestPipe;\n\n      case ParamTypes.NEXT_FN:\n        return context => context.next;\n\n      case ParamTypes.ERR:\n        return context => context.err;\n\n      case ParamTypes.CONTEXT:\n        return contextPipe;\n\n      case ParamTypes.ENDPOINT_INFO:\n        return context => contextPipe(context).endpoint;\n\n      case ParamTypes.RESPONSE_DATA:\n        return context => contextPipe(context).data;\n\n      default:\n        return this.getInvokableFilter(param, injector);\n    }\n  }\n\n  static getInvokableFilter(param: ParamMetadata, injector: InjectorService): any {\n    const target = param.service as Type<any>;\n    const {expression} = param;\n\n    return (context: IParamContext) => {\n      const instance = injector.get<IFilter>(target);\n\n      if (!instance || !instance.transform) {\n        throw new UnknowFilterError(target);\n      }\n\n      return instance.transform(expression, context.request, context.response);\n    };\n  }\n\n  private static getOperatorsPipe(param: ParamMetadata, injector: InjectorService) {\n    const operators = [\n      this.getInitialPipe(param, injector),\n      this.getParseExpressionPipe(param),\n      this.getRequiredPipe(param),\n      this.getValidationPipe(param, injector),\n      this.getConverterPipe(param, injector)\n    ]\n      .filter(Boolean)\n      .map(o => map(o!));\n\n    return (value: any) =>\n      of(value)\n        // @ts-ignore\n        .pipe(...operators)\n        .pipe(catchError(e => of(e)));\n  }\n\n  private static getContextPipe(param: ParamMetadata) {\n    return (context: IHandlerContext) => ({\n      ...context,\n      param,\n      expression: param.expression\n    });\n  }\n\n  public build(injector: InjectorService) {\n    const {param} = this;\n    const subject = new Subject<IHandlerContext>();\n    const observable = subject.pipe(\n      map(ParamBuilder.getContextPipe(param)),\n      switchMap(ParamBuilder.getOperatorsPipe(param, injector))\n    );\n\n    return {subject, observable};\n  }\n}\n"],"sourceRoot":"../../../src"}