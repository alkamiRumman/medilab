{"version":3,"sources":["mvc/builders/HandlerBuilder.ts"],"names":[],"mappings":"AACA,OAAO,EAAC,eAAe,EAAC,MAAM,UAAU,CAAC;AAIzC,OAAO,EAAC,eAAe,EAAC,MAAM,+BAA+B,CAAC;AAC9D,OAAO,EAAC,gBAAgB,EAAC,MAAM,4BAA4B,CAAC;AAC5D,OAAO,EAAC,eAAe,EAA6B,MAAM,2BAA2B,CAAC;AAItF;;GAEG;AACH,qBAAa,cAAc;IAGb,OAAO,CAAC,eAAe;IAFnC,OAAO,CAAC,KAAK,CAAU;gBAEH,eAAe,EAAE,eAAe;IAEpD;;;;OAIG;IACH,MAAM,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,GAAG,gBAAgB;;;IAgBvC,MAAM,CAAC,OAAO,CAAC,GAAG,EAAE,GAAG,GAAG,gBAAgB,EAAE,QAAQ,EAAE,eAAe;IAiCrE,MAAM,CAAC,MAAM,CAAC,OAAO,EAAE,GAAG,EAAE,OAAO,EAAE,eAAe;IAmDpD;;;OAGG;IACI,KAAK,CAAC,QAAQ,EAAE,eAAe,GAAG,GAAG;IA6B5C,OAAO,CAAC,gBAAgB;IAoCxB;;;;;OAKG;IACH,OAAO,CAAC,MAAM;IAgBd;;;;;OAKG;IACH,OAAO,CAAC,GAAG;IAoBX,OAAO,CAAC,YAAY;IAQpB;;;;OAIG;IACH,OAAO,CAAC,SAAS;CAmBlB","file":"HandlerBuilder.d.ts","sourcesContent":["import {isFunction, isPromise, isStream, nameOf} from \"@tsed/core\";\nimport {InjectorService} from \"@tsed/di\";\nimport {isObservable, Observable, Subject, zip} from \"rxjs\";\nimport {map} from \"rxjs/operators\";\nimport {HandlerType} from \"../interfaces/HandlerType\";\nimport {IHandlerContext} from \"../interfaces/IHandlerContext\";\nimport {EndpointMetadata} from \"../models/EndpointMetadata\";\nimport {HandlerMetadata, IHandlerConstructorOptions} from \"../models/HandlerMetadata\";\nimport {ParamMetadata} from \"../models/ParamMetadata\";\nimport {ParamBuilder} from \"./ParamBuilder\";\n\n/**\n * @stable\n */\nexport class HandlerBuilder {\n  private debug: boolean;\n\n  constructor(private handlerMetadata: HandlerMetadata) {}\n\n  /**\n   *\n   * @param obj\n   * @returns {HandlerBuilder}\n   */\n  static from(obj: any | EndpointMetadata) {\n    return {\n      build(injector: InjectorService) {\n        const handlerMetadata = HandlerBuilder.resolve(obj, injector);\n\n        if (handlerMetadata.type === HandlerType.FUNCTION) {\n          // injector.logger.debug(\"Return handler as function\", handlerMetadata.handler.name);\n          return handlerMetadata.handler;\n        }\n\n        // injector.logger.trace(\"Build handler\", `${nameOf(handlerMetadata.target)}.${handlerMetadata.method}()`);\n        return new HandlerBuilder(handlerMetadata).build(injector);\n      }\n    };\n  }\n\n  static resolve(obj: any | EndpointMetadata, injector: InjectorService) {\n    let options: IHandlerConstructorOptions;\n\n    if (obj instanceof EndpointMetadata) {\n      const provider = injector.getProvider(obj.target)!;\n\n      options = {\n        token: provider.provide,\n        target: provider.useClass,\n        type: HandlerType.CONTROLLER,\n        propertyKey: obj.propertyKey\n      };\n    } else {\n      const provider = injector.getProvider(obj);\n\n      if (provider) {\n        options = {\n          token: provider.provide,\n          target: provider.useClass,\n          type: HandlerType.MIDDLEWARE,\n          propertyKey: \"use\"\n        };\n      } else {\n        options = {\n          target: obj,\n          type: HandlerType.FUNCTION\n        };\n      }\n    }\n\n    return new HandlerMetadata(options);\n  }\n\n  static handle(process: any, context: IHandlerContext) {\n    const {\n      handler: {hasNextFunction},\n      request,\n      response,\n      next\n    } = context;\n\n    const done = (error: any, result?: any) => {\n      if (error) {\n        return next(error);\n      }\n\n      if (!hasNextFunction) {\n        // @ts-ignore\n        if (!next.isCalled && result !== undefined) {\n          request.ctx.data = result;\n        }\n        next();\n      }\n    };\n\n    if (process) {\n      if (process === context.response) {\n        return;\n      }\n\n      if (isObservable(process)) {\n        process = process.toPromise();\n      }\n\n      if (isStream(process)) {\n        return done(null, process);\n      }\n\n      if (isFunction(process)) {\n        // when process return a middleware\n        return process(request, response, next);\n      }\n\n      if (isPromise(process)) {\n        return process.then((result: any) => this.handle(result, context)).catch((error: any) => done(error));\n      }\n    }\n\n    if (!hasNextFunction) {\n      // no next function and empty response\n      done(null, process);\n    }\n  }\n\n  /**\n   *\n   * @returns {any}\n   */\n  public build(injector: InjectorService): any {\n    const {hasErrorParam} = this.handlerMetadata;\n\n    this.debug = injector.settings.debug;\n\n    const dispatch = this.createDispatcher(injector);\n\n    if (hasErrorParam) {\n      return (err: any, request: any, response: any, next: any) =>\n        dispatch({\n          request,\n          response,\n          next,\n          err,\n          handler: this.handlerMetadata,\n          args: []\n        });\n    } else {\n      return (request: any, response: any, next: any) =>\n        dispatch({\n          request,\n          response,\n          next,\n          handler: this.handlerMetadata,\n          args: []\n        });\n    }\n  }\n\n  private createDispatcher(injector: InjectorService) {\n    const {\n      handlerMetadata: {parameters}\n    } = this;\n    const requestSubject = new Subject<IHandlerContext>();\n    const sources: Subject<IHandlerContext>[] = [requestSubject];\n    const observables: Observable<any>[] = [requestSubject];\n\n    // Build parameters\n    parameters.forEach((param: ParamMetadata) => {\n      const {subject, observable} = new ParamBuilder(param).build(injector);\n      sources.push(subject);\n      observables.push(observable);\n    });\n\n    const mapContext = map(([context, ...args]) => {\n      context.args = args;\n      context.next = this.buildNext(context);\n\n      return context;\n    });\n\n    zip(...observables)\n      .pipe(mapContext)\n      .subscribe(context => this.invoke(injector, context));\n\n    // Return dispatcher\n    return (context: IHandlerContext) => {\n      this.log(context, {event: \"invoke.start\"});\n\n      sources.forEach(source => {\n        source.next(context);\n      });\n    };\n  }\n\n  /**\n   *\n   * @returns {Promise<any>}\n   * @param injector\n   * @param context\n   */\n  private invoke(injector: InjectorService, context: IHandlerContext) {\n    try {\n      const {token, method} = this.handlerMetadata;\n\n      this.checkContext(context);\n\n      const instance: any = injector.invoke(token, context.request.ctx.container);\n      const handler = instance[method!].bind(instance);\n      const process = handler(...context.args);\n\n      HandlerBuilder.handle(process, context);\n    } catch (error) {\n      context.next(error);\n    }\n  }\n\n  /**\n   *\n   * @param context\n   * @param o\n   * @returns {string}\n   */\n  private log(context: IHandlerContext, o: any = {}) {\n    const {request} = context;\n\n    if (request.log && this.debug) {\n      const {target, injectable, method} = this.handlerMetadata;\n\n      request.log.debug(\n        {\n          type: this.handlerMetadata.type,\n          target: (target ? nameOf(target) : target.name) || \"anonymous\",\n          methodName: method,\n          injectable,\n          data: request.ctx.data,\n          ...o\n        },\n        false\n      );\n    }\n  }\n\n  private checkContext(context: IHandlerContext) {\n    const error = context.args.find(arg => arg instanceof Error && arg !== context.err);\n\n    if (error) {\n      throw error;\n    }\n  }\n\n  /**\n   *\n   * @returns {any}\n   * @param context\n   */\n  private buildNext(context: IHandlerContext): any {\n    // @ts-ignore\n    const next = context.next as any;\n    const dateTime = Date.now();\n\n    next.isCalled = false;\n\n    return (error?: any) => {\n      next.isCalled = true;\n      if (context.response.headersSent) {\n        return;\n      }\n\n      /* istanbul ignore else */\n      this.log(context, {event: \"invoke.end\", error, execTime: Date.now() - dateTime});\n\n      return next(error);\n    };\n  }\n}\n"],"sourceRoot":"../../../src"}