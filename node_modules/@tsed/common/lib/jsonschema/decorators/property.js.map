{"version":3,"sources":["jsonschema/decorators/property.ts"],"names":[],"mappings":";;AAAA,qCAA8D;AAC9D,6BAA6B;AAG7B,qEAAgE;AAEhE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAyFG;AACH,uBAAuB;AACvB,SAAgB,YAAY,CAAC,OAAmC;IAC9D,OAAO,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,OAAO,CAAC,EAAE,gCAAgC,CAAC,CAAC;AAC7E,CAAC;AAFD,oCAEC;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAuFG;AACH,SAAgB,QAAQ,CAAC,OAAmC;IAC1D,OAAO,UAAU,CAAC,CAAC,gBAAkC,EAAE,EAAE;QACvD,IAAI,OAAO,OAAO,KAAK,QAAQ,EAAE;YAC/B,IAAI,CAAC,SAAS,CAAC,GAAG,EAAE,GAAE,CAAC,EAAE,2FAA2F,CAAC,EAAE,CAAC;YACxH,gBAAgB,CAAC,IAAI,GAAG,OAAiB,CAAC;SAC3C;aAAM,IAAI,OAAO,OAAO,KAAK,QAAQ,EAAE;YACtC,gBAAgB,CAAC,IAAI,GAAG,OAAO,CAAC,IAAc,CAAC;YAE/C,IAAI,CAAC,cAAO,CAAE,OAA4B,CAAC,GAAG,CAAC,EAAE;gBAC/C,gBAAgB,CAAC,IAAI,GAAI,OAA4B,CAAC,GAAgB,CAAC;aACxE;SACF;IACH,CAAC,CAAC,CAAC;AACL,CAAC;AAbD,4BAaC;AAED;;;;;;GAMG;AACH,SAAgB,UAAU,CAAC,EAAiF;IAC1G,OAAO,CAAC,GAAG,UAAiB,EAAO,EAAE;QACnC,MAAM,gBAAgB,GAAG,mCAAgB,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC;QAC5E,MAAM,MAAM,GAAQ,EAAE,CAAC,gBAAgB,EAAE,UAAiC,CAAC,CAAC;QAC5E,IAAI,OAAO,MAAM,KAAK,UAAU,EAAE;YAChC,MAAM,CAAC,GAAG,UAAU,CAAC,CAAC;SACvB;IACH,CAAC,CAAC;AACJ,CAAC;AARD,gCAQC","file":"property.js","sourcesContent":["import {DecoratorParameters, isEmpty, Type} from \"@tsed/core\";\nimport * as util from \"util\";\nimport {IPropertyOptions} from \"../../converters/interfaces/IPropertyOptions\";\nimport {PropertyMetadata} from \"../class/PropertyMetadata\";\nimport {PropertyRegistry} from \"../registries/PropertyRegistry\";\n\n/**\n * `@Property()` let you decorate an attribute that can be serialized or deserialized. By default, no parameters are required to use it.\n * But in some cases, we need to configure explicitly the JSON attribute name mapped to the provide attribute.\n *\n * Here an example of different use cases with `@Property()`:\n *\n * ```typescript\n * class EventModel {\n *\n *    @Property()\n *    name: string;\n *\n *    @Property()\n *    @Format('date-time')\n *    startDate: Date;\n *\n *    @Property({name: 'end-date'}) // alias nam doesn't work with JsonSchema\n *    @Format('date-time')\n *    endDate: Date;\n *\n *    @PropertyType(Task) // eq. @Property({use: Task})\n *    tasks: TaskModel[];\n * }\n *\n * class TaskModel {\n *     @Property()\n *     subject: string;\n *\n *     @Minimum(0)  // Property or Property is not required when a JsonSchema decorator is used\n *     @Maximum(100)\n *     rate: number;\n * }\n *\n * > Theses ES6 collections can be used: Map and Set. Map will be serialized as an object and Set as an array.\n * By default Date, Array, Map and Set have a default custom Converter already embed. But you can override theses (see next part).\n *\n * For the Array, you must use the `@PropertyType` decorator.\n * `TypeClass` will be used to deserialize each item in the collection stored on the attribute source.\n *\n * According to the previous example, the JsonSchema generated will be as follow:\n *\n * ```typescript\n * {\n *    \"type\": \"object\",\n *    \"properties\": {\n *       \"name\": {\n *          \"type\": \"string\"\n *       },\n *       \"startDate\": {\n *          \"type\": \"string\",\n *          \"format\": \"date-time\"\n *       },\n *       \"endDate\": {\n *          \"type\": \"string\",\n *          \"format\": \"date-time\"\n *       },\n *       \"tasks\": {\n *          \"type\": \"array\",\n *          \"items\": {\n *             \"$ref\": \"#/definitions/Task\"\n *          }\n *       }\n *    },\n *    \"definitions\": {\n *      \"Task\": {\n *        \"type\": \"object\",\n *        \"properties\": {\n *          \"subject\": {\n *             \"type\": \"string\",\n *          },\n *          \"rate\": {\n *             \"type\": \"number\"\n *             \"minimum\": 0,\n *             \"maximum: 100\n *          }\n *        }\n *      }\n *    }\n * }\n * ```\n *\n * @returns {Function}\n * @decorator\n * @param options\n * @decorator\n * @converters\n * @jsonschema\n * @property\n * @deprecated Use Property decorator instead\n */\n// istanbul ignore next\nexport function JsonProperty(options?: IPropertyOptions | string): Function {\n  return util.deprecate(Property(options), \"Use property decorator instead\");\n}\n\n/**\n * `@Property()` let you decorate an attribute that can be serialized or deserialized. By default, no parameters are required to use it.\n * But in some cases, we need to configure explicitly the JSON attribute name mapped to the provide attribute.\n *\n * Here an example of different use cases with `@Property()`:\n *\n * ```typescript\n * class EventModel {\n *\n *    @Property()\n *    name: string;\n *\n *    @Property()\n *    @Format('date-time')\n *    startDate: Date;\n *\n *    @Property({name: 'end-date'})\n *    @Format('date-time')\n *    endDate: Date;\n *\n *    @PropertyType(Task) // eq. @Property({use: Task})\n *    tasks: TaskModel[];\n * }\n *\n * class TaskModel {\n *     @Property()\n *     subject: string;\n *\n *     @Minimum(0)  // Property or Property is not required when a JsonSchema decorator is used\n *     @Maximum(100)\n *     rate: number;\n * }\n *\n * > Theses ES6 collections can be used: Map and Set. Map will be serialized as an object and Set as an array.\n * By default Date, Array, Map and Set have a default custom Converter already embed. But you can override theses (see next part).\n *\n * For the Array, you must use the `@PropertyType` decorator.\n * `TypeClass` will be used to deserialize each item in the collection stored on the attribute source.\n *\n * According to the previous example, the JsonSchema generated will be as follow:\n *\n * ```typescript\n * {\n *    \"type\": \"object\",\n *    \"properties\": {\n *       \"name\": {\n *          \"type\": \"string\"\n *       },\n *       \"startDate\": {\n *          \"type\": \"string\",\n *          \"format\": \"date-time\"\n *       },\n *       \"endDate\": {\n *          \"type\": \"string\",\n *          \"format\": \"date-time\"\n *       },\n *       \"tasks\": {\n *          \"type\": \"array\",\n *          \"items\": {\n *             \"$ref\": \"#/definitions/Task\"\n *          }\n *       }\n *    },\n *    \"definitions\": {\n *      \"Task\": {\n *        \"type\": \"object\",\n *        \"properties\": {\n *          \"subject\": {\n *             \"type\": \"string\",\n *          },\n *          \"rate\": {\n *             \"type\": \"number\"\n *             \"minimum\": 0,\n *             \"maximum: 100\n *          }\n *        }\n *      }\n *    }\n * }\n * ```\n *\n * @returns {Function}\n * @param options\n * @decorator\n * @converters\n * @jsonschema\n * @property\n */\nexport function Property(options?: IPropertyOptions | string): Function {\n  return PropertyFn((propertyMetadata: PropertyMetadata) => {\n    if (typeof options === \"string\") {\n      util.deprecate(() => {}, \"@Property(name: string) are deprecated. Use @Property(options:  IPropertyOptions) instead\")();\n      propertyMetadata.name = options as string;\n    } else if (typeof options === \"object\") {\n      propertyMetadata.name = options.name as string;\n\n      if (!isEmpty((options as IPropertyOptions).use)) {\n        propertyMetadata.type = (options as IPropertyOptions).use as Type<any>;\n      }\n    }\n  });\n}\n\n/**\n * Decorator builder. Call your function with `propertyMetadata` and `DecoratorParameters` a input parameters\n * @decorator\n * @converters\n * @jsonschema\n * @property\n */\nexport function PropertyFn(fn: (propertyMetadata: PropertyMetadata, parameters: DecoratorParameters) => void): Function {\n  return (...parameters: any[]): any => {\n    const propertyMetadata = PropertyRegistry.get(parameters[0], parameters[1]);\n    const result: any = fn(propertyMetadata, parameters as DecoratorParameters);\n    if (typeof result === \"function\") {\n      result(...parameters);\n    }\n  };\n}\n"],"sourceRoot":"../../../src"}