{"version":3,"sources":["jsonschema/decorators/property.ts"],"names":[],"mappings":"AAAA,OAAO,EAAC,mBAAmB,EAAgB,MAAM,YAAY,CAAC;AAE9D,OAAO,EAAC,gBAAgB,EAAC,MAAM,8CAA8C,CAAC;AAC9E,OAAO,EAAC,gBAAgB,EAAC,MAAM,2BAA2B,CAAC;AAG3D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAyFG;AAEH,wBAAgB,YAAY,CAAC,OAAO,CAAC,EAAE,gBAAgB,GAAG,MAAM,GAAG,QAAQ,CAE1E;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAuFG;AACH,wBAAgB,QAAQ,CAAC,OAAO,CAAC,EAAE,gBAAgB,GAAG,MAAM,GAAG,QAAQ,CAatE;AAED;;;;;;GAMG;AACH,wBAAgB,UAAU,CAAC,EAAE,EAAE,CAAC,gBAAgB,EAAE,gBAAgB,EAAE,UAAU,EAAE,mBAAmB,KAAK,IAAI,GAAG,QAAQ,CAQtH","file":"property.d.ts","sourcesContent":["import {DecoratorParameters, isEmpty, Type} from \"@tsed/core\";\nimport * as util from \"util\";\nimport {IPropertyOptions} from \"../../converters/interfaces/IPropertyOptions\";\nimport {PropertyMetadata} from \"../class/PropertyMetadata\";\nimport {PropertyRegistry} from \"../registries/PropertyRegistry\";\n\n/**\n * `@Property()` let you decorate an attribute that can be serialized or deserialized. By default, no parameters are required to use it.\n * But in some cases, we need to configure explicitly the JSON attribute name mapped to the provide attribute.\n *\n * Here an example of different use cases with `@Property()`:\n *\n * ```typescript\n * class EventModel {\n *\n *    @Property()\n *    name: string;\n *\n *    @Property()\n *    @Format('date-time')\n *    startDate: Date;\n *\n *    @Property({name: 'end-date'}) // alias nam doesn't work with JsonSchema\n *    @Format('date-time')\n *    endDate: Date;\n *\n *    @PropertyType(Task) // eq. @Property({use: Task})\n *    tasks: TaskModel[];\n * }\n *\n * class TaskModel {\n *     @Property()\n *     subject: string;\n *\n *     @Minimum(0)  // Property or Property is not required when a JsonSchema decorator is used\n *     @Maximum(100)\n *     rate: number;\n * }\n *\n * > Theses ES6 collections can be used: Map and Set. Map will be serialized as an object and Set as an array.\n * By default Date, Array, Map and Set have a default custom Converter already embed. But you can override theses (see next part).\n *\n * For the Array, you must use the `@PropertyType` decorator.\n * `TypeClass` will be used to deserialize each item in the collection stored on the attribute source.\n *\n * According to the previous example, the JsonSchema generated will be as follow:\n *\n * ```typescript\n * {\n *    \"type\": \"object\",\n *    \"properties\": {\n *       \"name\": {\n *          \"type\": \"string\"\n *       },\n *       \"startDate\": {\n *          \"type\": \"string\",\n *          \"format\": \"date-time\"\n *       },\n *       \"endDate\": {\n *          \"type\": \"string\",\n *          \"format\": \"date-time\"\n *       },\n *       \"tasks\": {\n *          \"type\": \"array\",\n *          \"items\": {\n *             \"$ref\": \"#/definitions/Task\"\n *          }\n *       }\n *    },\n *    \"definitions\": {\n *      \"Task\": {\n *        \"type\": \"object\",\n *        \"properties\": {\n *          \"subject\": {\n *             \"type\": \"string\",\n *          },\n *          \"rate\": {\n *             \"type\": \"number\"\n *             \"minimum\": 0,\n *             \"maximum: 100\n *          }\n *        }\n *      }\n *    }\n * }\n * ```\n *\n * @returns {Function}\n * @decorator\n * @param options\n * @decorator\n * @converters\n * @jsonschema\n * @property\n * @deprecated Use Property decorator instead\n */\n// istanbul ignore next\nexport function JsonProperty(options?: IPropertyOptions | string): Function {\n  return util.deprecate(Property(options), \"Use property decorator instead\");\n}\n\n/**\n * `@Property()` let you decorate an attribute that can be serialized or deserialized. By default, no parameters are required to use it.\n * But in some cases, we need to configure explicitly the JSON attribute name mapped to the provide attribute.\n *\n * Here an example of different use cases with `@Property()`:\n *\n * ```typescript\n * class EventModel {\n *\n *    @Property()\n *    name: string;\n *\n *    @Property()\n *    @Format('date-time')\n *    startDate: Date;\n *\n *    @Property({name: 'end-date'})\n *    @Format('date-time')\n *    endDate: Date;\n *\n *    @PropertyType(Task) // eq. @Property({use: Task})\n *    tasks: TaskModel[];\n * }\n *\n * class TaskModel {\n *     @Property()\n *     subject: string;\n *\n *     @Minimum(0)  // Property or Property is not required when a JsonSchema decorator is used\n *     @Maximum(100)\n *     rate: number;\n * }\n *\n * > Theses ES6 collections can be used: Map and Set. Map will be serialized as an object and Set as an array.\n * By default Date, Array, Map and Set have a default custom Converter already embed. But you can override theses (see next part).\n *\n * For the Array, you must use the `@PropertyType` decorator.\n * `TypeClass` will be used to deserialize each item in the collection stored on the attribute source.\n *\n * According to the previous example, the JsonSchema generated will be as follow:\n *\n * ```typescript\n * {\n *    \"type\": \"object\",\n *    \"properties\": {\n *       \"name\": {\n *          \"type\": \"string\"\n *       },\n *       \"startDate\": {\n *          \"type\": \"string\",\n *          \"format\": \"date-time\"\n *       },\n *       \"endDate\": {\n *          \"type\": \"string\",\n *          \"format\": \"date-time\"\n *       },\n *       \"tasks\": {\n *          \"type\": \"array\",\n *          \"items\": {\n *             \"$ref\": \"#/definitions/Task\"\n *          }\n *       }\n *    },\n *    \"definitions\": {\n *      \"Task\": {\n *        \"type\": \"object\",\n *        \"properties\": {\n *          \"subject\": {\n *             \"type\": \"string\",\n *          },\n *          \"rate\": {\n *             \"type\": \"number\"\n *             \"minimum\": 0,\n *             \"maximum: 100\n *          }\n *        }\n *      }\n *    }\n * }\n * ```\n *\n * @returns {Function}\n * @param options\n * @decorator\n * @converters\n * @jsonschema\n * @property\n */\nexport function Property(options?: IPropertyOptions | string): Function {\n  return PropertyFn((propertyMetadata: PropertyMetadata) => {\n    if (typeof options === \"string\") {\n      util.deprecate(() => {}, \"@Property(name: string) are deprecated. Use @Property(options:  IPropertyOptions) instead\")();\n      propertyMetadata.name = options as string;\n    } else if (typeof options === \"object\") {\n      propertyMetadata.name = options.name as string;\n\n      if (!isEmpty((options as IPropertyOptions).use)) {\n        propertyMetadata.type = (options as IPropertyOptions).use as Type<any>;\n      }\n    }\n  });\n}\n\n/**\n * Decorator builder. Call your function with `propertyMetadata` and `DecoratorParameters` a input parameters\n * @decorator\n * @converters\n * @jsonschema\n * @property\n */\nexport function PropertyFn(fn: (propertyMetadata: PropertyMetadata, parameters: DecoratorParameters) => void): Function {\n  return (...parameters: any[]): any => {\n    const propertyMetadata = PropertyRegistry.get(parameters[0], parameters[1]);\n    const result: any = fn(propertyMetadata, parameters as DecoratorParameters);\n    if (typeof result === \"function\") {\n      result(...parameters);\n    }\n  };\n}\n"],"sourceRoot":"../../../src"}