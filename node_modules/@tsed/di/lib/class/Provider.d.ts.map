{"version":3,"sources":["class/Provider.ts"],"names":[],"mappings":"AAAA,OAAO,EAA+D,KAAK,EAAE,IAAI,EAAC,MAAM,YAAY,CAAC;AACrG,OAAO,EAAC,uBAAuB,EAAE,aAAa,EAAC,MAAM,eAAe,CAAC;AACrE,OAAO,EAAC,SAAS,EAAC,MAAM,yBAAyB,CAAC;AAClD,OAAO,EAAC,YAAY,EAAC,MAAM,4BAA4B,CAAC;AACxD,OAAO,EAAC,aAAa,EAAC,MAAM,6BAA6B,CAAC;AAE1D,qBAAa,QAAQ,CAAC,CAAC,CAAE,YAAW,SAAS,CAAC,CAAC,CAAC;IAEvC,IAAI,EAAE,OAAO,CAAS;IAGtB,IAAI,EAAE,YAAY,GAAG,GAAG,CAAyB;IAGjD,UAAU,EAAE,OAAO,CAAQ;IAG3B,QAAQ,EAAE,CAAC,CAAC;IAGZ,IAAI,EAAE,GAAG,EAAE,CAAC;IAGZ,OAAO,EAAE,GAAG,EAAE,CAAC;IAGf,UAAU,EAAE,QAAQ,CAAC;IAGrB,eAAe,EAAE,QAAQ,CAAC;IAG1B,QAAQ,EAAE,GAAG,CAAC;IAGrB,SAAS,CAAC,QAAQ,EAAE,aAAa,CAAC;IAGlC,SAAS,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;IAG7B,SAAS,CAAC,SAAS,EAAE,CAAC,CAAC;IAGvB,OAAO,CAAC,MAAM,CAAQ;IAEtB,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAC;gBAEP,KAAK,EAAE,aAAa;aAK5B,KAAK;IAIL,OAAO,EAAI,aAAa;;;;;IAWxB,QAAQ,EAAI,IAAI,CAAC,CAAC,CAAC;aAgBnB,SAAS;aAIT,IAAI;aAIG,KAAK,EAAI,KAAK;IAIzB;;;;;;;;OAQG;;;;;IACC,KAAK,EAAI,aAAa;IAiBtB,aAAa,EAAI,OAAO,CAAC,uBAAuB,CAAC;IASrD,OAAO,IAAI,OAAO;IAIlB,KAAK,IAAI,QAAQ,CAAC,GAAG,CAAC;IAYtB,QAAQ;CAGT","file":"Provider.d.ts","sourcesContent":["import {classOf, Enumerable, getKeys, isClass, nameOf, NotEnumerable, Store, Type} from \"@tsed/core\";\nimport {IDIConfigurationOptions, ProviderScope} from \"../interfaces\";\nimport {IProvider} from \"../interfaces/IProvider\";\nimport {ProviderType} from \"../interfaces/ProviderType\";\nimport {TokenProvider} from \"../interfaces/TokenProvider\";\n\nexport class Provider<T> implements IProvider<T> {\n  @Enumerable()\n  public root: boolean = false;\n\n  @Enumerable()\n  public type: ProviderType | any = ProviderType.PROVIDER;\n\n  @Enumerable()\n  public injectable: boolean = true;\n\n  @Enumerable()\n  public instance: T;\n\n  @Enumerable()\n  public deps: any[];\n\n  @Enumerable()\n  public imports: any[];\n\n  @Enumerable()\n  public useFactory: Function;\n\n  @Enumerable()\n  public useAsyncFactory: Function;\n\n  @Enumerable()\n  public useValue: any;\n\n  @NotEnumerable()\n  protected _provide: TokenProvider;\n\n  @NotEnumerable()\n  protected _useClass: Type<T>;\n\n  @NotEnumerable()\n  protected _instance: T;\n\n  @NotEnumerable()\n  private _store: Store;\n\n  [key: string]: any;\n\n  constructor(token: TokenProvider) {\n    this.provide = token;\n    this.useClass = token;\n  }\n\n  get token() {\n    return this._provide;\n  }\n\n  get provide(): TokenProvider {\n    return this._provide;\n  }\n\n  set provide(value: TokenProvider) {\n    if (value) {\n      this._provide = isClass(value) ? classOf(value) : value;\n      this._store = Store.from(value);\n    }\n  }\n\n  get useClass(): Type<T> {\n    return this._useClass;\n  }\n\n  /**\n   * Create a new store if the given value is a class. Otherwise the value is ignored.\n   * @param value\n   */\n  @Enumerable()\n  set useClass(value: Type<T>) {\n    if (isClass(value)) {\n      this._useClass = classOf(value);\n      this._store = Store.from(value);\n    }\n  }\n\n  get className() {\n    return this.name;\n  }\n\n  get name() {\n    return nameOf(this.provide);\n  }\n\n  public get store(): Store {\n    return this._store;\n  }\n\n  /**\n   * Get the scope of the provider.\n   *\n   * ::: tip Note\n   * Async provider is always a SINGLETON\n   * :::\n   *\n   * @returns {boolean}\n   */\n  get scope(): ProviderScope {\n    if (this.isAsync()) {\n      return ProviderScope.SINGLETON;\n    }\n\n    return this.store.get(\"scope\");\n  }\n\n  /**\n   * Change the scope value of the provider.\n   * @param scope\n   */\n  @Enumerable()\n  set scope(scope: ProviderScope) {\n    this.store.set(\"scope\", scope);\n  }\n\n  get configuration(): Partial<IDIConfigurationOptions> {\n    return this.store.get(\"configuration\");\n  }\n\n  @Enumerable()\n  set configuration(configuration: Partial<IDIConfigurationOptions>) {\n    this.store.set(\"configuration\", configuration);\n  }\n\n  isAsync(): boolean {\n    return !!this.useAsyncFactory;\n  }\n\n  clone(): Provider<any> {\n    const provider = new (classOf(this))(this.token);\n\n    getKeys(this).forEach(key => {\n      if (this[key] !== undefined) {\n        provider[key] = this[key];\n      }\n    });\n\n    return provider;\n  }\n\n  toString() {\n    return `Token:${this.name}`;\n  }\n}\n"],"sourceRoot":"../../src"}