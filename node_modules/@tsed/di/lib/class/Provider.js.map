{"version":3,"sources":["class/Provider.ts"],"names":[],"mappings":";;;AAAA,qCAAqG;AACrG,8CAAqE;AAErE,6DAAwD;AAGxD,MAAa,QAAQ;IA0CnB,YAAY,KAAoB;QAxCzB,SAAI,GAAY,KAAK,CAAC;QAGtB,SAAI,GAAuB,2BAAY,CAAC,QAAQ,CAAC;QAGjD,eAAU,GAAY,IAAI,CAAC;QAmChC,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;QACrB,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC;IACxB,CAAC;IAED,IAAI,KAAK;QACP,OAAO,IAAI,CAAC,QAAQ,CAAC;IACvB,CAAC;IAED,IAAI,OAAO;QACT,OAAO,IAAI,CAAC,QAAQ,CAAC;IACvB,CAAC;IAED,IAAI,OAAO,CAAC,KAAoB;QAC9B,IAAI,KAAK,EAAE;YACT,IAAI,CAAC,QAAQ,GAAG,cAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,cAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;YACxD,IAAI,CAAC,MAAM,GAAG,YAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;SACjC;IACH,CAAC;IAED,IAAI,QAAQ;QACV,OAAO,IAAI,CAAC,SAAS,CAAC;IACxB,CAAC;IAED;;;OAGG;IAEH,IAAI,QAAQ,CAAC,KAAc;QACzB,IAAI,cAAO,CAAC,KAAK,CAAC,EAAE;YAClB,IAAI,CAAC,SAAS,GAAG,cAAO,CAAC,KAAK,CAAC,CAAC;YAChC,IAAI,CAAC,MAAM,GAAG,YAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;SACjC;IACH,CAAC;IAED,IAAI,SAAS;QACX,OAAO,IAAI,CAAC,IAAI,CAAC;IACnB,CAAC;IAED,IAAI,IAAI;QACN,OAAO,aAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;IAC9B,CAAC;IAED,IAAW,KAAK;QACd,OAAO,IAAI,CAAC,MAAM,CAAC;IACrB,CAAC;IAED;;;;;;;;OAQG;IACH,IAAI,KAAK;QACP,IAAI,IAAI,CAAC,OAAO,EAAE,EAAE;YAClB,OAAO,0BAAa,CAAC,SAAS,CAAC;SAChC;QAED,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;IACjC,CAAC;IAED;;;OAGG;IAEH,IAAI,KAAK,CAAC,KAAoB;QAC5B,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;IACjC,CAAC;IAED,IAAI,aAAa;QACf,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,eAAe,CAAC,CAAC;IACzC,CAAC;IAGD,IAAI,aAAa,CAAC,aAA+C;QAC/D,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,eAAe,EAAE,aAAa,CAAC,CAAC;IACjD,CAAC;IAED,OAAO;QACL,OAAO,CAAC,CAAC,IAAI,CAAC,eAAe,CAAC;IAChC,CAAC;IAED,KAAK;QACH,MAAM,QAAQ,GAAG,IAAI,CAAC,cAAO,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAEjD,cAAO,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE;YAC1B,IAAI,IAAI,CAAC,GAAG,CAAC,KAAK,SAAS,EAAE;gBAC3B,QAAQ,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC;aAC3B;QACH,CAAC,CAAC,CAAC;QAEH,OAAO,QAAQ,CAAC;IAClB,CAAC;IAED,QAAQ;QACN,OAAO,SAAS,IAAI,CAAC,IAAI,EAAE,CAAC;IAC9B,CAAC;CACF;AA9IC;IADC,iBAAU,EAAE;;sCACgB;AAG7B;IADC,iBAAU,EAAE;;sCAC2C;AAGxD;IADC,iBAAU,EAAE;;4CACqB;AAGlC;IADC,iBAAU,EAAE;;0CACM;AAGnB;IADC,iBAAU,EAAE;;sCACM;AAGnB;IADC,iBAAU,EAAE;;yCACS;AAGtB;IADC,iBAAU,EAAE;sCACM,QAAQ;4CAAC;AAG5B;IADC,iBAAU,EAAE;sCACW,QAAQ;iDAAC;AAGjC;IADC,iBAAU,EAAE;;0CACQ;AAGrB;IADC,oBAAa,EAAE;;0CACkB;AAGlC;IADC,oBAAa,EAAE;sCACK,WAAI;2CAAI;AAG7B;IADC,oBAAa,EAAE;;2CACO;AAGvB;IADC,oBAAa,EAAE;sCACA,YAAK;wCAAC;AAiCtB;IADC,iBAAU,EAAE;sCACO,WAAI;6CAAJ,WAAI;wCAKvB;AAoCD;IADC,iBAAU,EAAE;;;qCAGZ;AAOD;IADC,iBAAU,EAAE;;;6CAGZ;AA3HH,4BAgJC","file":"Provider.js","sourcesContent":["import {classOf, Enumerable, getKeys, isClass, nameOf, NotEnumerable, Store, Type} from \"@tsed/core\";\nimport {IDIConfigurationOptions, ProviderScope} from \"../interfaces\";\nimport {IProvider} from \"../interfaces/IProvider\";\nimport {ProviderType} from \"../interfaces/ProviderType\";\nimport {TokenProvider} from \"../interfaces/TokenProvider\";\n\nexport class Provider<T> implements IProvider<T> {\n  @Enumerable()\n  public root: boolean = false;\n\n  @Enumerable()\n  public type: ProviderType | any = ProviderType.PROVIDER;\n\n  @Enumerable()\n  public injectable: boolean = true;\n\n  @Enumerable()\n  public instance: T;\n\n  @Enumerable()\n  public deps: any[];\n\n  @Enumerable()\n  public imports: any[];\n\n  @Enumerable()\n  public useFactory: Function;\n\n  @Enumerable()\n  public useAsyncFactory: Function;\n\n  @Enumerable()\n  public useValue: any;\n\n  @NotEnumerable()\n  protected _provide: TokenProvider;\n\n  @NotEnumerable()\n  protected _useClass: Type<T>;\n\n  @NotEnumerable()\n  protected _instance: T;\n\n  @NotEnumerable()\n  private _store: Store;\n\n  [key: string]: any;\n\n  constructor(token: TokenProvider) {\n    this.provide = token;\n    this.useClass = token;\n  }\n\n  get token() {\n    return this._provide;\n  }\n\n  get provide(): TokenProvider {\n    return this._provide;\n  }\n\n  set provide(value: TokenProvider) {\n    if (value) {\n      this._provide = isClass(value) ? classOf(value) : value;\n      this._store = Store.from(value);\n    }\n  }\n\n  get useClass(): Type<T> {\n    return this._useClass;\n  }\n\n  /**\n   * Create a new store if the given value is a class. Otherwise the value is ignored.\n   * @param value\n   */\n  @Enumerable()\n  set useClass(value: Type<T>) {\n    if (isClass(value)) {\n      this._useClass = classOf(value);\n      this._store = Store.from(value);\n    }\n  }\n\n  get className() {\n    return this.name;\n  }\n\n  get name() {\n    return nameOf(this.provide);\n  }\n\n  public get store(): Store {\n    return this._store;\n  }\n\n  /**\n   * Get the scope of the provider.\n   *\n   * ::: tip Note\n   * Async provider is always a SINGLETON\n   * :::\n   *\n   * @returns {boolean}\n   */\n  get scope(): ProviderScope {\n    if (this.isAsync()) {\n      return ProviderScope.SINGLETON;\n    }\n\n    return this.store.get(\"scope\");\n  }\n\n  /**\n   * Change the scope value of the provider.\n   * @param scope\n   */\n  @Enumerable()\n  set scope(scope: ProviderScope) {\n    this.store.set(\"scope\", scope);\n  }\n\n  get configuration(): Partial<IDIConfigurationOptions> {\n    return this.store.get(\"configuration\");\n  }\n\n  @Enumerable()\n  set configuration(configuration: Partial<IDIConfigurationOptions>) {\n    this.store.set(\"configuration\", configuration);\n  }\n\n  isAsync(): boolean {\n    return !!this.useAsyncFactory;\n  }\n\n  clone(): Provider<any> {\n    const provider = new (classOf(this))(this.token);\n\n    getKeys(this).forEach(key => {\n      if (this[key] !== undefined) {\n        provider[key] = this[key];\n      }\n    });\n\n    return provider;\n  }\n\n  toString() {\n    return `Token:${this.name}`;\n  }\n}\n"],"sourceRoot":"../../src"}