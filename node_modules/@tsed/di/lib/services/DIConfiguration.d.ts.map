{"version":3,"sources":["services/DIConfiguration.ts"],"names":[],"mappings":"AACA,OAAO,EAAC,uBAAuB,EAAC,MAAM,uCAAuC,CAAC;AAC9E,OAAO,EAAC,aAAa,EAAC,MAAM,6BAA6B,CAAC;AAE1D,qBAAa,eAAe;IAC1B,SAAS,CAAC,GAAG,EAAE,GAAG,CAAC,MAAM,EAAE,GAAG,CAAC,CAAa;IAE5C,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAC;gBAEP,YAAY,KAAK;IAiDzB,MAAM,EAAI;QAAC,CAAC,GAAG,EAAE,MAAM,GAAG,aAAa,CAAA;KAAC;IAQ5C;;;;OAIG;IACH,OAAO,CAAC,UAAU,EAAE,CAAC,KAAK,EAAE,GAAG,EAAE,KAAK,EAAE,MAAM,EAAE,GAAG,EAAE,GAAG,CAAC,MAAM,EAAE,GAAG,CAAC,KAAK,IAAI,EAAE,OAAO,CAAC,EAAE,GAAG;IAI7F;;;;OAIG;IACH,GAAG,CAAC,WAAW,EAAE,MAAM,GAAG,OAAO,CAAC,uBAAuB,CAAC,EAAE,KAAK,CAAC,EAAE,GAAG,GAAG,IAAI;IAU9E;;;;OAIG;IACH,GAAG,CAAC,CAAC,EAAE,WAAW,EAAE,MAAM,GAAG,CAAC;IAI9B,KAAK,CAAC,GAAG,EAAE,OAAO,CAAC,uBAAuB,CAAC;IAc3C;;;;OAIG;IACH,OAAO,CAAC,KAAK,EAAE,GAAG;IAgBlB,WAAW,IAAI,uBAAuB;CAOvC","file":"DIConfiguration.d.ts","sourcesContent":["import {deepClone, deepExtends, getValue, setValue} from \"@tsed/core\";\nimport {IDIConfigurationOptions} from \"../interfaces/IDIConfigurationOptions\";\nimport {ProviderScope} from \"../interfaces/ProviderScope\";\n\nexport class DIConfiguration {\n  protected map: Map<string, any> = new Map();\n\n  [key: string]: any;\n\n  constructor(initialProps = {}) {\n    this.set({\n      scopes: {},\n      ...initialProps\n    });\n\n    return new Proxy(this, {\n      getOwnPropertyDescriptor(target: any, p: PropertyKey): PropertyDescriptor | undefined {\n        return Reflect.getOwnPropertyDescriptor(target, p);\n      },\n\n      has(target: any, p: PropertyKey): boolean {\n        if (Reflect.has(target, p) || typeof p === \"symbol\") {\n          return Reflect.has(target, p);\n        }\n\n        return target.get(p as any) !== undefined;\n      },\n\n      get(target: any, p: PropertyKey, receiver: any): any {\n        if (Reflect.has(target, p) || typeof p === \"symbol\") {\n          return Reflect.get(target, p, receiver);\n        }\n\n        return target.get(p as any);\n      },\n\n      set(target: DIConfiguration, p: PropertyKey, value: any, receiver: any): boolean {\n        if (Reflect.has(target, p) || typeof p === \"symbol\") {\n          return Reflect.set(target, p, value, receiver);\n        }\n\n        return !!target.set(p as any, value);\n      },\n\n      deleteProperty(target: any, p: PropertyKey): boolean {\n        return Reflect.deleteProperty(target, p);\n      },\n\n      defineProperty(target: any, p: PropertyKey, attributes: PropertyDescriptor): boolean {\n        return Reflect.defineProperty(target, p, attributes);\n      },\n\n      ownKeys(target: DIConfiguration): PropertyKey[] {\n        return Reflect.ownKeys(target).concat(Array.from(target.map.keys()));\n      }\n    });\n  }\n\n  get scopes(): {[key: string]: ProviderScope} {\n    return this.map.get(\"scopes\");\n  }\n\n  set scopes(value: {[key: string]: ProviderScope}) {\n    this.map.set(\"scopes\", value);\n  }\n\n  /**\n   *\n   * @param callbackfn\n   * @param thisArg\n   */\n  forEach(callbackfn: (value: any, index: string, map: Map<string, any>) => void, thisArg?: any) {\n    return this.map.forEach(callbackfn, thisArg);\n  }\n\n  /**\n   *\n   * @param propertyKey\n   * @param value\n   */\n  set(propertyKey: string | Partial<IDIConfigurationOptions>, value?: any): this {\n    if (typeof propertyKey === \"string\") {\n      setValue(propertyKey, value, this.map);\n    } else {\n      Object.assign(this, propertyKey);\n    }\n\n    return this;\n  }\n\n  /**\n   *\n   * @param propertyKey\n   * @returns {undefined|any}\n   */\n  get<T>(propertyKey: string): T {\n    return this.resolve(getValue(propertyKey, this.map));\n  }\n\n  merge(obj: Partial<IDIConfigurationOptions>) {\n    Object.entries(obj).forEach(([key, value]) => {\n      const descriptor = Object.getOwnPropertyDescriptor(DIConfiguration.prototype, key);\n      const originalValue = this.get(key);\n      value = deepExtends(value, originalValue);\n\n      if (descriptor && [\"set\", \"map\", \"get\"].indexOf(key) === -1) {\n        this[key] = value;\n      } else {\n        this.set(key, value);\n      }\n    });\n  }\n\n  /**\n   *\n   * @param value\n   * @returns {any}\n   */\n  resolve(value: any) {\n    if (typeof value === \"object\" && value !== null) {\n      Object.entries(value).forEach(([k, v]) => {\n        value[k] = this.resolve(v);\n      });\n\n      return value;\n    }\n\n    if (typeof value === \"string\") {\n      return value.replace(/\\${([\\w.]+)}/gi, (match, key) => getValue(key, this.map));\n    }\n\n    return value;\n  }\n\n  toRawObject(): IDIConfigurationOptions {\n    return Array.from(this.map.entries()).reduce((obj: any, [key, value]) => {\n      obj[key] = deepClone(value);\n\n      return obj;\n    }, {});\n  }\n}\n"],"sourceRoot":"../../src"}