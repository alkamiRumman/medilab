"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@tsed/core");
class DIConfiguration {
    constructor(initialProps = {}) {
        this.map = new Map();
        this.set(Object.assign({ scopes: {} }, initialProps));
        return new Proxy(this, {
            getOwnPropertyDescriptor(target, p) {
                return Reflect.getOwnPropertyDescriptor(target, p);
            },
            has(target, p) {
                if (Reflect.has(target, p) || typeof p === "symbol") {
                    return Reflect.has(target, p);
                }
                return target.get(p) !== undefined;
            },
            get(target, p, receiver) {
                if (Reflect.has(target, p) || typeof p === "symbol") {
                    return Reflect.get(target, p, receiver);
                }
                return target.get(p);
            },
            set(target, p, value, receiver) {
                if (Reflect.has(target, p) || typeof p === "symbol") {
                    return Reflect.set(target, p, value, receiver);
                }
                return !!target.set(p, value);
            },
            deleteProperty(target, p) {
                return Reflect.deleteProperty(target, p);
            },
            defineProperty(target, p, attributes) {
                return Reflect.defineProperty(target, p, attributes);
            },
            ownKeys(target) {
                return Reflect.ownKeys(target).concat(Array.from(target.map.keys()));
            }
        });
    }
    get scopes() {
        return this.map.get("scopes");
    }
    set scopes(value) {
        this.map.set("scopes", value);
    }
    /**
     *
     * @param callbackfn
     * @param thisArg
     */
    forEach(callbackfn, thisArg) {
        return this.map.forEach(callbackfn, thisArg);
    }
    /**
     *
     * @param propertyKey
     * @param value
     */
    set(propertyKey, value) {
        if (typeof propertyKey === "string") {
            core_1.setValue(propertyKey, value, this.map);
        }
        else {
            Object.assign(this, propertyKey);
        }
        return this;
    }
    /**
     *
     * @param propertyKey
     * @returns {undefined|any}
     */
    get(propertyKey) {
        return this.resolve(core_1.getValue(propertyKey, this.map));
    }
    merge(obj) {
        Object.entries(obj).forEach(([key, value]) => {
            const descriptor = Object.getOwnPropertyDescriptor(DIConfiguration.prototype, key);
            const originalValue = this.get(key);
            value = core_1.deepExtends(value, originalValue);
            if (descriptor && ["set", "map", "get"].indexOf(key) === -1) {
                this[key] = value;
            }
            else {
                this.set(key, value);
            }
        });
    }
    /**
     *
     * @param value
     * @returns {any}
     */
    resolve(value) {
        if (typeof value === "object" && value !== null) {
            Object.entries(value).forEach(([k, v]) => {
                value[k] = this.resolve(v);
            });
            return value;
        }
        if (typeof value === "string") {
            return value.replace(/\${([\w.]+)}/gi, (match, key) => core_1.getValue(key, this.map));
        }
        return value;
    }
    toRawObject() {
        return Array.from(this.map.entries()).reduce((obj, [key, value]) => {
            obj[key] = core_1.deepClone(value);
            return obj;
        }, {});
    }
}
exports.DIConfiguration = DIConfiguration;

//# sourceMappingURL=DIConfiguration.js.map
